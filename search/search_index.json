{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to the ISDN2602 Final Project Website</p>"},{"location":"#changelog","title":"Changelog","text":""},{"location":"#2025-11-22-update-control-panel-section","title":"[2025-11-22] Update Control Panel Section","text":"<p>To include Traffic Light System Control and Timer Control note.</p>"},{"location":"#2025-11-21-rfid-task","title":"[2025-11-21] RFID Task","text":"<p>Change 1 - In files <code>CodeWithFirebase/CodeWithFirebase.ino</code> and <code>CodeWithoutFireBase/CodeWithoutFireBase.ino</code> at lines 363 and 372, modify the RFID tag reader task to store the current tag UID in a global variable: <pre><code>/*-------------RFID Tag Reader Task-------------*/\nTaskHandle_t RFIDTagReaderTaskHandle = NULL;\nStaticTask_t xRFIDTagReaderTCB;\n+ String currenttagUID = \"\";\nvoid RFIDTagReaderTask(void* pvPara) {\n  while (true) {\n    // If no new card or read failed, wait and continue\n    if (!RFIDReader::mfrc522.PICC_IsNewCardPresent() || !RFIDReader::mfrc522.PICC_ReadCardSerial()) {\n      vTaskDelay(pdMS_TO_TICKS(50));\n      continue;\n    }\n\n-   String currenttagUID = RFIDReader::GetTagUID();\n+   currenttagUID = RFIDReader::GetTagUID();\n</code></pre></p> <p>Change 2 - In files <code>CodeWithFirebase/RFIDReader.cpp</code> and <code>CodeWithoutFirebase/RFIDReader.cpp</code> at line 9, set the RFID antenna gain to maximum for better reading range:</p> <pre><code>  // Initialize RFID\n  Wire.begin(Pinout::RFID_SDA, Pinout::RFID_SCL);\n  mfrc522.PCD_Init();\n+ mfrc522.PCD_SetAntennaGain(mfrc522.RxGain_max);\n  Serial.println(\"RFID Initialized\");\n</code></pre> <p>Change 3 - In files <code>CodeWithFirebase/CodeWithFirebase.ino</code> and <code>CodeWithoutFireBase/CodeWithoutFireBase.ino</code>, please move the <code>RFIDTagReaderTask</code> definition above the <code>MovementTask</code>, so that the <code>currenttagUID</code> variable can be accessed in the <code>MovementTask</code>:</p> <p>That is to move the entire <code>RFIDTagReaderTask</code> code block up to be before the <code>MovementTask</code> code block, like so:</p> <pre><code>+ /*-------------RFID Tag Reader Task-------------*/\n+ TaskHandle_t RFIDTagReaderTaskHandle = NULL;\n+ StaticTask_t xRFIDTagReaderTCB;\n+ String currenttagUID = \"\";\n+ void RFIDTagReaderTask(void* pvPara) {\n+   // ...\n+ }\n\n/*-------------LED Blinking Task-------------*/\nTaskHandle_t LEDBlinkingTaskHandle = NULL;\nStaticTask_t xLEDBlinkingTCB;\nvoid LEDBlinkingTask(void* pvPara) {\n // ...\n};\n\nTaskHandle_t MovementTaskHandle = NULL;\nStaticTask_t xMovementTCB;\nvoid MovementTask(void* pvPara) {\n    // ...\n}\n\n- /*-------------RFID Tag Reader Task-------------*/\n- TaskHandle_t RFIDTagReaderTaskHandle = NULL;\n- StaticTask_t xRFIDTagReaderTCB;\n- String currenttagUID = \"\";\n- void RFIDTagReaderTask(void* pvPara) {\n-   // ...\n- }\n</code></pre>"},{"location":"#2025-11-19-810-pm-servo-and-rfid-fixes","title":"[2025-11-19 8:10 PM] Servo and RFID Fixes","text":"<p>In files <code>CodeWithFirebase/CodeWithFirebase.ino</code> and <code>CodeWithoutFireBase/CodeWithoutFireBase.ino</code> at line 377 to increase the delay time for RFID tag reading:</p> <pre><code>void RFIDTagReaderTask(void* pvPara) {\n    while (true) {\n        // ...\n-       vTaskDelay(pdMS_TO_TICKS(10));\n+       vTaskDelay(500/portTICK_PERIOD_MS);\n    }\n}\n</code></pre> <p>In files <code>CodeWithFirebase/MotorControl.hpp</code> and <code>CodeWithoutFireBase/MotorControl.hpp</code> at lines 28 and 30 to modify the PWM resolution and channel for the servo motor:</p> <pre><code>struct ServoMotor\n{\n    const uint8_t PWMFrequency = 50; // PWM must be in 50Hz\n-   const uint8_t PWMResolution = 12;\n+   const uint8_t PWMResolution = 10;\n    uint16_t PWMDuty = 0;\n-   const uint8_t PWMChannel = 8; // Ideally select between 5-10\n+   const uint8_t PWMChannel = 6; // Ideally select between 5-10\n    float TargetAngle = 0.0f;\n};\n</code></pre>"},{"location":"#2025-11-18-735-pm-ultrasonic-sensor-pin-change","title":"[2025-11-18 7:35 PM] Ultrasonic Sensor Pin Change","text":"<p>In files <code>CodeWithFirebase/Pinout.hpp</code> and <code>CodeWithoutFireBase/Pinout.hpp</code> at lines 20 and 21, the ultrasonic sensor pins have been changed as follows:</p> <pre><code>// Ultrasonic Sensor \n- const uint8_t UltrasonicTrigPin = 6;\n+ const uint8_t UltrasonicTrigPin = 39;\n- const uint8_t UltrasonicEchoPin = 4;\n+ const uint8_t UltrasonicEchoPin = 38;\n</code></pre>"},{"location":"#2025-11-18-release-of-final-project","title":"[2025-11-18] Release of Final Project","text":""},{"location":"#notes","title":"Notes","text":"<p>If you have already cloned the repository, you will receive a pull request with the updated changes, please refer to the image below to accept and merge the changes. Or you may choose to manually update the code that have been changed.</p> <p></p>"},{"location":"batteryRecharing/","title":"Battery Recharging","text":"<p>Each team will be provided with a smart car and two rechargeable LiPo batteries to power your smart car during the final demo and testing, all labelled with your team number (e.g. Final Project Group 18 will have the car labelled as '18' and the batteries labelled as '18A' and '18B').</p>"},{"location":"batteryRecharing/#steps-to-recharge-the-battery","title":"Steps to Recharge the Battery","text":"<ol> <li> <p>Unlock the safety box and open the lid.</p> <p>Inside the box, you will see the Balance Charger B6AC and the charging module for you to plugin your battery.</p> </li> <li> <p>Turn on the power supply. </p> <p>The screen of the Balance Charger will light up.</p> </li> <li> <p>Switch off the black toggle switch on charging module. </p> </li> <li> <p>Plugin your battery to the charging module.</p> <p>Pay attention to the orientation of the battery connector (do not force push if it does not fit) and ensure it is firmly connected.</p> </li> <li> <p>On the Balance Charger, select the battery type and set the charging current according to the battery specifications. </p> <p>If you see 'LiPo Balance' mode with 2.4A and 7.4V (2S), then it's correct.</p> <p>If not, please press the 'Batt. Type' button, select 'LiPo Batt', click 'Enter' button to confirm. Then use the 'Dec' and 'Inc' buttons to select 'LiPo Balance with 2.4A and 7.4V (2S)'.</p> </li> <li> <p>Switch on the switch on charging module. </p> </li> <li> <p>Long press the 'Start/Enter' button on Balance Charger</p> <p>If it prompts \"CONNECTION BREAK\", please double-check you have correctly plugged in the battery and turned on the switch on the charging module.</p> <p>If it shows the battery module and the text 'CONFIRM(ENTER)', click 'Start/Enter' button again to start charging.</p> </li> <li> <p>Done, wait for the charging to complete. Please close back the safety box lid.</p> </li> </ol>"},{"location":"batteryRecharing/#steps-to-take-out-the-battery-after-recharging","title":"Steps to Take Out the Battery After Recharging","text":"<ol> <li>Press the 'Stop / Batt. Type' button on the Balance Charger to stop charging.</li> <li>Switch off the black toggle switch on charging module.</li> <li>Unplug your battery from the charging module.</li> </ol> <p>If no other batteries are charging, please</p> <ol> <li>Turn off the power supply.</li> <li>Close the lid of the safety box and lock it.</li> </ol> <p>If there're others' batteries still charging, please redo the above charging steps.</p>"},{"location":"controlPanel/","title":"Control Panel","text":"<p>We will be using the control panel to configure the final demo setting and send commands to your smart cars, including the demo timer, task ID, start and end points, etc. </p> <p>The control panel links directly to the Firebase realtime database which your car will be given the <code>WEB API KEY</code> to read off data from it. </p> <p>We will also be giving you the access to use the control panel for testing, which your data will be stored under your own user ID, similar to what you have done during the Firebase lab. </p> <p>You need to </p> <ol> <li>Sign up and login to the control panel at our Control Panel Site: panel.isdn2602.site</li> <li>Copy your user ID (should be visible at the top right corner of the app)</li> <li>Input the user ID string to your skeleton code (so your car will only read your commands and not be confused by others' commands)</li> <li>(Optional) Turn on the <code>Serial.print</code> for retrieving Firebase data and see if the data matches the command you set on your control panel</li> </ol> <p>Notice</p> <ol> <li>Any attempts to write to the Realtime database other than those allowed on the control panel website is strictly prohibited.</li> <li>Please only use the control panel when necessary i.e. when you are testing and are physically present at Room 4223.</li> <li>Please close the website when it is not in use to minimize data traffic.</li> <li>Please remember your username and password for login. We currently do no provide account retrieval service.</li> </ol>"},{"location":"controlPanel/#traffic-light-system-control","title":"Traffic Light System Control","text":"<p>To reduce the data traffic, we have designed that traffic light system can only be controlled by admin. If you have done with the basic functionalities and would like to test the traffic light system with dynamic status, please let us know and we will turn on the system to change the traffic light status for you.</p>"},{"location":"controlPanel/#timer-control","title":"Timer Control","text":"<p>Again to reduce data traffic and delay, the timer is updated only on changes (i.e. start, pause, reset). The timer will not be updated every second.</p>"},{"location":"map/","title":"Map Layout","text":""},{"location":"map/#map-layout-for-final-project-arena","title":"Map Layout for Final Project Arena","text":"<ul> <li>For tile board RFID information, please refer to Board IDs from 1 - 25</li> <li>For traffic light information, please use traffic light IDs 1 - 4</li> <li>The 3 parking slots have been labelled with IDs 1 - 3. You should park the car accordingly to the parking slot at the given end point.</li> </ul>"},{"location":"map/#map-layout-for-testing-field","title":"Map Layout for Testing Field","text":"<ul> <li>For tile board RFID information, please refer to Board IDs from 26 - 35</li> <li>For traffic light information, please use traffic light ID 5</li> </ul> <p>Notice</p> <ul> <li>You may walk on the pathway between the two fields to retrieve your car during testing, but do not step on the fields or remove the fences around the fields.</li> <li>Also, please do not remove any tiles and make sure they are properly connected to each other.</li> </ul>"},{"location":"network/","title":"Network Configuration","text":"<p>For ESP32 boards (or other MCU that is not compatible with 5GHz) please connect to:</p> <ul> <li>WIFI SSID (2.4GHz): <code>ISDN2602_2G</code></li> <li>WIFI Password: <code>isdn2602@iot</code></li> </ul> <ul> <li>Please input the above network credentials to your final project code for your smart car to connect to the internet.</li> <li>You don't need to connect your device to the same network to use the control panel.</li> </ul>"},{"location":"qna/","title":"Q &amp; A","text":"<p>Please use the comment section below to ask any questions you have about the project, documentation, or anything related. We'll do our best to respond promptly and help clarify any doubts.</p> <p>If you think you can help answer other classmates' questions, feel free to contribute!</p>"},{"location":"rfidReference/","title":"Tile RFID Reference","text":"<p>Here you can find the RFID tags to all tiles: Complete List of all Tiles' RFID</p> <p>The final demo arena consists of 5*5 = 25 Tiles with the Tile Board IDs showing below: </p> <p>Following the same numbering scheme, the testing field consists of 2*5 = 10 Tiles with the Tile Board IDs from 26 to 35.</p> <p>Each tile consists of 9 RFIDs with the indices showing below:</p> <ul> <li>0 as the center RFID</li> <li>1 and 2 for UP direction</li> <li>3 and 4 for DOWN direction</li> <li>5 and 6 for LEFT direction</li> <li>7 and 8 for RIGHT direction</li> </ul> <p></p>"},{"location":"uploadConfig/","title":"Upload Config","text":"<p>The Board we are using is ESP32S3 Dev Module</p> <p></p>"},{"location":"skeleton_code/","title":"Skeleton Codebase","text":"<p>Please accept the Github Classroom invitation link to access the Skeleton Code Repository.</p> <p>This repository is team-based. Each team member should accept the invitation to join the repository with the correct group number. You and your team members will have access to push code to the same repository. We will also check the code submitted in this repository for grading.</p>"},{"location":"skeleton_code/firebase/","title":"Firebase related","text":"<p>Tip</p> <p>You are recommended to start with the CodeWithoutFirebase folder, first work on basic functionalities of your smart car. </p> <p>Once everything is functioning well, you can proceed to the CodeWithFirebase folder (replace those files you have edited) to integrate Firebase functionalities of getting realtime examStates and traffic light status.</p> <p>If you really want to set up the routes for your smart car without Firebase, you can hardcode some values for the examState and traffic light status.</p>"},{"location":"skeleton_code/firebase/#arduino-libraries-needed-to-be-installed","title":"Arduino Libraries Needed to be Installed","text":"<p>FirebaseClient (latest version &gt;= 2.2)</p> <p></p> <p>ArduinoJson (latest version &gt;= 7.4)</p> <p></p>"},{"location":"skeleton_code/firebase/#firebase-configuration","title":"Firebase configuration","text":"<p>In the <code>config.cpp</code> file</p> <pre><code>// TODO\n// Demo config\nconst bool demoMode = false;\n// Set to true to enable demo mode - to read from examStates data from /admin\n// Set to false to read from /users/&lt;uid&gt;/examState when testing by yourself\n\n// WiFi Configuration\nconst char WIFI_SSID[] = \"ISDN2602_2G\";\nconst char WIFI_PASSWORD[] = \"isdn2602@iot\";\n\n// Firebase Credentials (Should already be there in the skeleton code)\nconst String API_KEY = \"AIzaSyD***************\";  \nconst String DATABASE_URL =\n    \"https://isdn2602-control-panel-2025-default-rtdb.firebaseio.com/\";\n// TODO\nconst String UID = \"your-uid\";  // you can find it from the\n                                // control panel site\n\n//... Other configurations ...\n</code></pre> <p>Info</p> <p>If you have not sign up an account on the control panel website, please checkout Control Panel page and follow the instructions there to do so.</p> <ul> <li>You need to input your user ID (obtained from the control panel website) to get the examState data from your own path</li> <li>During testing you should set the <code>demoMode</code> to false to read under your own path with your user ID</li> <li>Before the actual demo day of the final project, you should upload the code with <code>demoMode = true</code> in order to receive the examState commands sent from the admin</li> </ul>"},{"location":"skeleton_code/firebase/#firebase-related-code-explanation","title":"Firebase related code explanation","text":""},{"location":"skeleton_code/firebase/#firebase-components","title":"Firebase components","text":"<pre><code>/* Firebase Components */\nFirebaseApp app;\nWiFiClientSecure ssl_client1;\nusing AsyncClient = AsyncClientClass;\nAsyncClient aClient1(ssl_client1);\nRealtimeDatabase Database;\nNoAuth no_auth;;\n</code></pre> <ul> <li><code>FirebaseApp app;</code> - The main Firebase application instance, manages overall Firebase connections and authentication states</li> <li><code>WiFiClientSecure ssl_client1;</code> - Secure Wi-Fi client for SSL/TLS connections, required for Firebase communication</li> <li><code>AsyncClient aClient1(ssl_client1);</code> - Asynchronous client for Firebase operations, enables non-blocking requests</li> <li><code>RealtimeDatabase Database;</code> - Instance for interacting with Firebase Realtime Database, provides methods to read/write data</li> <li><code>NoAuth no_auth;</code> - No authentication instance (no need for email/password authentication in this case for faster and convenient access)</li> </ul>"},{"location":"skeleton_code/firebase/#firebase-tasks","title":"Firebase Tasks","text":""},{"location":"skeleton_code/firebase/#inside-void-setup","title":"Inside <code>void setup()</code>","text":"<pre><code>void setup() {\n    // ...\n    // Other sensors initialization ...\n\n    // Initialize the Wi-Fi Connection\n    // LED blinking while connecting to WiFi\n    WiFiManager::initialize();\n\n    // Configure SSL clients\n    ssl_client1.setInsecure();\n    ssl_client1.setConnectionTimeout(1000);\n    ssl_client1.setHandshakeTimeout(5);\n\n    // Initialize Firebase Realtime Database\n    initializeApp(aClient1, app, getAuth(no_auth), processData);\n    app.getApp&lt;RealtimeDatabase&gt;(Database);\n    Database.url(DATABASE_URL);\n    Serial.println(\"FireBase Initialized\");\n\n    // ...\n    xTaskCreatePinnedToCore(FirebaseMainTask, \"Firebase Main Task\", 8192, NULL, 1,\n                          &amp;FirebaseMainTaskTCB, 0);\n    xTaskCreatePinnedToCore(FirebaseReadTask, \"Firebase Read Task\", 8192, NULL, 2,\n                          &amp;FirebaseReadTaskTCB, 0);\n\n    // Other tasks initialization ...\n    // ...\n\n    vTaskDelay(10);\n\n}\n</code></pre> <ul> <li><code>WiFiManager::initialize();</code> - Establishes WiFi connection before Firebase can work, with LED indication during connection</li> <li><code>ssl_client1</code> - Set up for insecure connection and timeouts for Firebase communication</li> <li><code>initializeApp(...)</code> - Initializes the Firebase app with the provided async client, authentication method;</li> <li><code>processData</code> - The callback function for handling Firebase responses</li> <li><code>app.getApp&lt;RealtimeDatabase&gt;(Database);</code> and <code>Database.url(DATABASE_URL);</code> - Sets up the Realtime Database instance with the specified database URL defined in config file</li> <li><code>xTaskCreatePinnedToCore(Firebase ...)</code> </li> <li>Creates FreeRTOS tasks for handling Firebase main operations and reading data from the database</li> <li>Pin both tasks to Core 0 to separate Firebase from other operations and to enable WiFi stability</li> </ul>"},{"location":"skeleton_code/firebase/#firebase-main-task","title":"Firebase Main Task","text":"<pre><code>/* Firebase Main Task */\nStackType_t uxFirebaseMainTask[configMINIMAL_STACK_SIZE];\nStaticTask_t xFirebaseMainTaskTCB;\nTaskHandle_t FirebaseMainTaskTCB;\n\nvoid FirebaseMainTask(void* pvPara) {\n  while (true) {\n    // Check WiFi connection first\n    if (WiFiManager::isConnected()) {\n    } else {\n      Serial.println(\"WiFi disconnected, attempting to reconnect...\");\n      WiFiManager::reconnect();\n    }\n    // Handle Firebase tasks\n    app.loop();\n    vTaskDelay(pdMS_TO_TICKS(50));\n  }\n}\n</code></pre> <p><code>if (WiFiManager::isConnected()) {} else { ... }</code></p> <ul> <li>Continuously checks WiFi connection status</li> <li>Automatically attempts reconnection if disconnected</li> </ul> <p><code>app.loop();</code></p> <ul> <li>Must be called regularly for Firebase to function</li> <li>Processes Firebase tasks, handles incoming/outgoing data</li> <li>Handles callbacks from async operations</li> </ul>"},{"location":"skeleton_code/firebase/#firebase-read-task","title":"Firebase Read Task","text":"<pre><code>/* Firebase Read Task */\nStackType_t uxFirebaseReadTask[configMINIMAL_STACK_SIZE];\nStaticTask_t xFirebaseReadTaskTCB;\nTaskHandle_t FirebaseReadTaskTCB;\n\nvoid FirebaseReadTask(void* pvPara) {\n  while (true) {\n    // Check if authentication is ready\n    if (app.ready()) {\n      unsigned long currentTime = millis();\n      // Periodic data reading every readInterval, but only if not busy\n      if (currentTime - lastReadTime &gt;= readInterval &amp;&amp; !readingBusy) {\n        lastReadTime = currentTime;  // Update the last read time\n        readingBusy = true;          // Set busy before request\n\n        // Debug - Log the request paths\n        // Serial.println(\"Requesting exam state from: \" + examStatePath);\n        // Serial.println(\"Requesting traffic lights from: \" +\n        // trafficLightPath);\n\n        Database.get(aClient1, examStatePath, processData, false,\n                     \"RTDB_GetExamState\");\n        Database.get(aClient1, trafficLightPath, processData, false,\n                     \"RTDB_GetTrafficLight\");\n\n        readingBusy = false;  // Clear busy after request\n      }\n    }\n    vTaskDelay(pdMS_TO_TICKS(200));\n  }\n}\n</code></pre> <p><pre><code>if (app.ready()) { }\n</code></pre>  - Ensures Firebase is ready before attempting reads to prevent errors</p> <pre><code>unsigned long currentTime = millis();\nif (currentTime - lastReadTime &gt;= readInterval &amp;&amp; !readingBusy) { }\n</code></pre> <ul> <li><code>millis()</code>: Current time since boot (in milliseconds)</li> <li>Reads data at regular intervals (e.g., every 1000ms = 1 second)</li> <li><code>readingBusy</code> flag prevents overlapping requests</li> <li>Avoids overwhelming Firebase with too many requests</li> </ul> <pre><code>Database.get(aClient1, examStatePath, processData, false, \"RTDB_GetExamState\");\n</code></pre> <ul> <li><code>aClient1</code>: Async client to use for the request</li> <li><code>examStatePath</code>: Database path (e.g., <code>/users/&lt;uid&gt;/examState</code>)</li> <li><code>processData</code>: Callback function to handle the response</li> <li><code>false</code>: Don't use Server-Sent Events (SSE) streaming</li> <li><code>\"RTDB_GetExamState\"</code>: Unique identifier for this request (used in callback)<ul> <li>Exam State: Current task assignment (start point, end point, field, etc.)</li> <li>Traffic Lights: States of all traffic lights (red, yellow, green, timing)</li> </ul> </li> </ul>"},{"location":"skeleton_code/firebase/#firebase-helper-function","title":"Firebase helper function","text":"<pre><code>/* Firebase Data Processing Helper Function */\nvoid processData(AsyncResult&amp; aResult) {\n  if (!aResult.isResult()) return;\n\n  //   DEBUG - Log event, debug, and error messages\n  // if (aResult.isEvent())\n  //   Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\",\n  //                   aResult.uid().c_str(),\n  //                   aResult.eventLog().message().c_str(),\n  //                   aResult.eventLog().code());\n\n  // if (aResult.isDebug())\n  //   Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(),\n  //                   aResult.debug().c_str());\n\n  //   if (aResult.isError())\n  //     Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\",\n  //                     aResult.uid().c_str(),\n  //                     aResult.error().message().c_str(),\n  //                     aResult.error().code());\n\n  if (aResult.available()) {\n    // DEBUG - Log the task and payload\n    // Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(),\n    //                 aResult.c_str());\n\n    DynamicJsonDocument doc(1024);\n    DeserializationError error = deserializeJson(doc, aResult.c_str());\n    if (error) {\n      Firebase.printf(\"Failed to parse JSON: %s\\n\", error.c_str());\n      return;\n    }\n    JsonObject obj = doc.as&lt;JsonObject&gt;();\n\n    if (aResult.uid() == \"RTDB_GetExamState\") {\n      examState.activated = obj[\"activated\"].as&lt;bool&gt;();\n      examState.start_point = obj[\"start_point\"].as&lt;int&gt;();\n      examState.end_point = obj[\"end_point\"].as&lt;int&gt;();\n      examState.field = obj[\"field\"].as&lt;String&gt;();\n      examState.task_id = obj[\"task_id\"].as&lt;int&gt;();\n      examState.time_remain = obj[\"time_remain\"].as&lt;int&gt;();\n      //  Debug - print the current exam state\n      //   Serial.println(\"===== Exam State =====\");\n      //   Serial.println(\"Activated: \" + String(examState.activated));\n      //   Serial.println(\"Start Point: \" + String(examState.start_point));\n      //   Serial.println(\"End Point: \" + String(examState.end_point));\n      //   Serial.println(\"Field: \" + examState.field);\n      //   Serial.println(\"Task ID: \" + String(examState.task_id));\n      //   Serial.println(\"Time Remain: \" + String(examState.time_remain));\n    }\n    if (aResult.uid() == \"RTDB_GetTrafficLight\") {\n      JsonArray arr = doc.as&lt;JsonArray&gt;();\n      // Debug - print each traffic light\n      // Serial.println(\"===== Traffic Light States =====\");\n      // Parse traffic lights data\n      // Light ID 1-4 are for final exam, ID 5 is for the testing field\n      for (int i = 0; i &lt; numTrafficLights + 1 &amp;&amp; i &lt; arr.size(); i++) {\n        JsonObject light = arr[i];\n        if (!light.isNull()) {\n          trafficLights[i].id = light[\"id\"].as&lt;int&gt;();\n          trafficLights[i].current_state = light[\"current_state\"].as&lt;String&gt;();\n          trafficLights[i].time_remain = light[\"time_remain\"].as&lt;int&gt;();\n\n          // Debug - print each traffic light\n          // Serial.printf(\"Light %d: id=%d, state=%s, time_remain=%d\\n\", i,\n          //               trafficLights[i].id,\n          //               trafficLights[i].current_state.c_str(),\n          //               trafficLights[i].time_remain);\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"skeleton_code/firebase/#result-validating","title":"Result validating","text":"<pre><code>if (!aResult.isResult()) return;\n</code></pre> <ul> <li>Checks if callback contains actual data</li> <li>Returns early if called for non-data events</li> </ul>"},{"location":"skeleton_code/firebase/#error-checking","title":"Error checking","text":"<p>(For debugging purposes - commented out by default)</p> <ul> <li><code>isEvent()</code>: Firebase connection events</li> <li><code>isDebug()</code>: Debug messages from Firebase</li> <li><code>isError()</code>: Authentication or network errors</li> </ul>"},{"location":"skeleton_code/firebase/#json-parsing","title":"JSON parsing","text":"<pre><code>DynamicJsonDocument doc(1024);\nDeserializationError error = deserializeJson(doc, aResult.c_str());\n</code></pre> <ul> <li>Creates a JSON document to hold parsed data</li> <li>Parses the raw JSON string from Firebase</li> <li>Returns error if JSON is malformed</li> </ul>"},{"location":"skeleton_code/firebase/#exam-state-processing","title":"Exam State processing","text":"<pre><code>if (aResult.uid() == \"RTDB_GetExamState\") { }\n</code></pre> <ul> <li>Identifies request by unique ID</li> <li>Extracts each field from JSON object</li> <li>Updates global <code>examState</code> structure</li> <li>examState structure fields:</li> </ul> <pre><code>struct ExamState {\n    bool activated = false; \n    int start_point;\n    int end_point;\n    String field; // either \"final project arena\" or \"testing field\"\n    int task_id;\n    int time_remain;\n};\n</code></pre> <ul> <li>Your car should only start moving when <code>activated</code> is true</li> </ul>"},{"location":"skeleton_code/firebase/#traffic-light-processing","title":"Traffic Light processing","text":"<pre><code>if (aResult.uid() == \"RTDB_GetTrafficLight\") { }\n</code></pre> <ul> <li>Parses JSON array of traffic lights and stores all lights into the global <code>trafficLights[]</code> array</li> <li>Each element represents one traffic light</li> <li>Loop updates all traffic lights (IDs 1-5)</li> <li>trafficLights structure fields:</li> </ul> <pre><code>struct TrafficLight {\n  int id;\n  String current_state;\n  int time_remain;\n};\n</code></pre>"},{"location":"skeleton_code/firebase/#debugging-notes","title":"Debugging notes","text":"<p>If you encounter issue reading data from Firebase, please turn on the <code>Serial.print</code> debug info in the <code>processData</code> function to see what is going on.</p>"},{"location":"skeleton_code/hardware-pinout/","title":"Hardware and Pinout","text":""},{"location":"skeleton_code/hardware-pinout/#schematic-of-the-chassis-board-power-system","title":"Schematic of the chassis board (Power System)","text":""},{"location":"skeleton_code/hardware-pinout/#schematic-of-the-chassis-board-mcu-related","title":"Schematic of the chassis board (MCU related)","text":""},{"location":"skeleton_code/main/","title":"Main Code <code>.ino</code> File","text":"<p>This section include the basic of FreeRTOS, Tasks, PID Control and detail of the code in <code>.ino</code> file (without Firebase, for Firebase part please refer to the Firebase section).</p> <p>Most of the code will be written in this file for your project. </p>"},{"location":"skeleton_code/main/#freertos","title":"FreeRTOS","text":"<p>For detail, please visit FreeRTOS official website: FreeRTOS Task Creation</p>"},{"location":"skeleton_code/main/#task","title":"Task","text":"<p>Take blinking a LED as an example, a \u201cTask\u201d consists of:</p> <ul> <li>Stack</li> <li>TCB</li> <li>Handle</li> </ul> <p>Inside the task function, there are 2 major parts: setup (only run once) and loop (run forever)</p> <p>Please be reminded that vTaskDelay() MUST be added inside the while loop.  <pre><code>/*------------LED Blinking Task-------------\n  --------Stack and Handle Settings---------\nTo ensure there is visualization that the program is running*/\nStackType_t uxBlinkTaskStack[configMINIMAL_STACK_SIZE];\nStaticTask_t xBlinkTaskTCB;\nTaskHandle_t BlinkTaskTCB;\n\n\n\nvoid Blink(void *pvPara)\n{\n  /*Setup for the task*/\n  pinMode(LED1, OUTPUT);\n  /*DO*/\n  while(true){\n  digitalWrite(LED1,HIGH);\n  vTaskDelay(100);\n  digitalWrite(LED1, LOW);\n  vTaskDelay(200);\n  }\n}\n</code></pre></p>"},{"location":"skeleton_code/main/#core-configuration-of-esp32s3","title":"Core Configuration of ESP32S3","text":"Core Purpose 0 Wifi / Bluetooth Connection 1 Local Control"},{"location":"skeleton_code/main/#xtaskcreatepinnedtocore","title":"<code>xTaskCreatePinnedToCore()</code>","text":"<p>Create FreeRTOS tasks with proper namespaced functions Task creation function: <pre><code>  TaskHandle_t xTaskCreateStaticPinnedToCore(\n      TaskFunction_t pxTaskCode,\n      const char *const pcName,\n      const uint32_t ulStackDepth,\n      void *const pvParameters,\n      UBaseType_t uxPriority,\n      StackType_t *const puxStackBuffer,\n      StaticTask_t *const pxTaskBuffer,\n      const BaseType_t xCoreID\n  );\n</code></pre></p> <p>Example of creating the task of blinking and pin to core 1 of ESP32S3.  <pre><code>xTaskCreatePinnedToCore(Blink, \"Blink\", 2048, NULL, 1 , &amp;BlinkTaskTCB, 1 );\n</code></pre></p>"},{"location":"skeleton_code/main/#chassisskeletoncodeino","title":"<code>ChassisSkeletonCode.ino</code>","text":"<p>These files should be included:  <pre><code>#include &lt;Arduino.h&gt;\n#include \"Pinout.hpp\"\n#include \"MotorControl.hpp\"\n#include \"IRSensors.hpp\"\n#include \"Movement.hpp\"\n#include \"MFRC522_I2C.hpp\" //Driver for RFID Reader\n#include \"UltrasonicSensor.hpp\"\n#include \"Buzzer.hpp\" //Buzzer in case you want to debug using buzzer\n#include \"pitches.h\" //For Buzzer\n#include \"IMU.h\" //Optional IMU driver used in sensor lab, \n                  // Please refer to the Sensor lab code for how to use IMU API \n</code></pre></p>"},{"location":"skeleton_code/main/#pid-control","title":"PID Control","text":"<p>This section will explain and guide you how to use the PID driver provided in the skeleton code. </p>"},{"location":"skeleton_code/main/#pid_t-struct","title":"PID_t (struct)","text":"<p>Using struct for handling multiple PIDs (i.e. Speed of Left &amp; Right wheel motor)</p> <p>Also, create a member function to compute the PID using different set of PID para.  <pre><code>{\n  /*Creating the parameters for PID*/\n  volatile float Kp;\n  volatile float Ki;\n  volatile float Kd;\n\n  volatile float target_val; // The target RPM\n  float actual_val;          // Actual RPM Reading\n  float err;                 // Error\n  float err_last;\n  float integral;\n\n  /*General PID Function*/\n  float PID_realize(float temp_val)\n  {\n    this-&gt;err = this-&gt;target_val - temp_val;\n\n    this-&gt;integral += this-&gt;err;\n\n    this-&gt;actual_val = this-&gt;Kp * this-&gt;err + this-&gt;Ki * this-&gt;integral +\n                       this-&gt;Kd * (this-&gt;err - this-&gt;err_last);\n\n    this-&gt;err_last = this-&gt;err;\n\n    return this-&gt;actual_val;\n  }\n\n} PID;\n</code></pre></p> <p>Create the PID struct (Gobally) <pre><code>/*Global PID controllers for left and right wheels*/\nPID_t LeftWheelPID;\nPID_t RightWheelPID;\n</code></pre></p>"},{"location":"skeleton_code/main/#void-speedcontroltaskvoid-pvpara","title":"<code>void SpeedControlTask(void* pvPara)</code>","text":"<p>Before entering the loop, initialize all the PID value </p> <p>In <code>void SpeedControlTask(void* pvPara)</code> <pre><code>  /*Setup for the Task*/\n  /*----------------------------------------------------*/\n  /*Initalize the Speed of the motor*/\n  MotorControl::LeftWheel.Speed = 0;\n  MotorControl::RightWheel.Speed = 0;\n\n  /*Initialize PID Parameters*/\n  /*LeftMotor PID*/\n  LeftWheelPID.Kp = 0.0f;\n  LeftWheelPID.Ki = 0.0f;\n  LeftWheelPID.Kd = 0.0f;\n  LeftWheelPID.target_val = 150.0f;\n  LeftWheelPID.err = 0.0f;\n  LeftWheelPID.err_last = 0.0f;\n  LeftWheelPID.integral = 0.0f;\n\n  /*RightMotor PID*/\n  RightWheelPID.Kp = 0.0f;\n  RightWheelPID.Ki = 0.0f;\n  RightWheelPID.Kd = 0.0f;\n  RightWheelPID.target_val = 150.0f;\n  RightWheelPID.err = 0.0f;\n  RightWheelPID.err_last = 0.0f;\n  RightWheelPID.integral = 0.0f;\n  /*----------------------------------------------------*/\n</code></pre> After initializing all the para., get the current RPM of the wheels and store them in struct RPMCounter_t. </p> <p>Then set the target value of the PID as <code>MotorControl::LeftWheel.Speed</code> &amp; <code>MotorControl::RightWheel.Speed</code>, actual value as <code>LeftWheelRPM.rpm</code> &amp; <code>RightWheelRPM.rpm</code>. </p> <p>Finally, run the PID function to mantain the speed of wheels.  <pre><code>  while (true) {\n    /*----------------------------------------------------*/\n    /*Get the RPM from Encoder*/\n    Encoder::RPMCounterFromEncoder(LeftWheelRPM);\n    Encoder::RPMCounterFromEncoder(RightWheelRPM);\n    /*----------------------------------------------------*/\n    /*Compute the PID and Write the Result to Speed of the Wheel*/\n    MotorControl::LeftWheel.Speed = LeftWheelPID.PID_realize(LeftWheelRPM.rpm);\n    MotorControl::RightWheel.Speed =RightWheelPID.PID_realize(RightWheelRPM.rpm);\n    /*----------------------------------------------------*/\n    /*FOR DEBUG USAGE*/\n    Serial.print(\"Speed Left: \");\n    Serial.println(MotorControl::LeftWheel.Speed);\n\n    Serial.print(\"Speed Right: \");\n    Serial.println(MotorControl::RightWheel.Speed);\n    /*----------------------------------------------------*/\n    /*A delay must be added inside each User Task*/\n    vTaskDelay(50);\n    }\n</code></pre></p>"},{"location":"skeleton_code/main/#void-movementtaskboid-para","title":"<code>void MovementTask(boid* para)</code>","text":"<p>This task is for line tracking (by default)</p> <p>You can  also write your RFID nagivation code here.  <pre><code> while (true) {\n    // Get the status of the IR sensor and store in IRData\n    IRSensors::IRData.state = IRSensors::ReadSensorState(IRSensors::IRData);\n    /*-------For Debug Use------*/\n    // Serial.print(\"IR Status: \");\n    // Serial.print(IRSensors::IRData.Read_IR_L);\n    // Serial.print(IRSensors::IRData.Read_IR_M);\n    // Serial.println(IRSensors::IRData.Read_IR_R);\n\n    // Serial.print(\"Condition: \");\n    // Serial.println(IRSensors::IRData.state);\n    // Depend on the condition, do line tracking\n    // Using switch case for the movement control\n    switch (IRSensors::IRData.state) {\n      case IRSensors::Middle_ON_Track:\n        LeftWheelPID.target_val = 150.0f;\n        RightWheelPID.target_val = 150.0f;\n        Movement::MoveForward();\n        vTaskDelay(100);\n        break;\n\n      case IRSensors::Left_Middle_ON_Track:\n        LeftWheelPID.target_val = 150.0f;\n        RightWheelPID.target_val = 150.0f;\n        Movement::RotateLeft();\n        vTaskDelay(100);\n        break;\n\n      case IRSensors::ALL_ON_Track:\n        LeftWheelPID.target_val = 150.0f;\n        RightWheelPID.target_val = 150.0f;\n        Movement::Stop();\n        vTaskDelay(100);\n        break;\n\n      case IRSensors::Left_Right_ON_Track:\n        LeftWheelPID.target_val = 150.0f;\n        RightWheelPID.target_val = 150.0f;\n        Movement::Stop();\n        vTaskDelay(100);\n        break;\n\n      case IRSensors::Middle_Right_ON_Track:\n        LeftWheelPID.target_val = 150.0f;\n        RightWheelPID.target_val = 150.0f;\n        Movement::RotateRight();\n        vTaskDelay(100);\n        break;\n\n      case IRSensors::Right_ON_Track:\n        LeftWheelPID.target_val = 150.0f;\n        RightWheelPID.target_val = 150.0f;\n        Movement::RotateRight();\n        vTaskDelay(100);\n        break;\n\n      case IRSensors::Left_ON_Track:\n        LeftWheelPID.target_val = 150.0f;\n        RightWheelPID.target_val = 150.0f;\n        Movement::RotateLeft();\n        vTaskDelay(100);\n        break;\n\n      case IRSensors::All_OFF_Track:\n        LeftWheelPID.target_val = 150.0f;\n        RightWheelPID.target_val = 150.0f;\n        Movement::Stop();\n        vTaskDelay(100);\n        break;\n    }\n        // /*-------For Debug Use------*/\n        // Serial.print(\"LeftWheel.Speed: \");\n        // Serial.println(MotorControl::LeftWheel.Speed);\n        // Serial.print(\"RightWheel.Speed: \");\n        // Serial.println(MotorControl::RightWheel.Speed);\n\n        // /*-------For Debug Use------*/\n        // Serial.print(\"LeftWheel.PWMIN1: \");\n        // Serial.print(MotorControl::LeftWheel.PWMChannelIN1);\n        // Serial.println(MotorControl::LeftWheel.PWMChannelIN2);\n\n        // Serial.print(\"RightWheel.PWMIN2: \");\n        // Serial.print(MotorControl::RightWheel.PWMChannelIN1);\n        // Serial.println(MotorControl::RightWheel.PWMChannelIN2);\n    vTaskDelay(10);\n  }\n};\n</code></pre></p>"},{"location":"skeleton_code/main/#void-setup-without-firebase","title":"<code>void setup()</code> Without Firebase","text":"<p>In <code>void setup()</code>, </p> <p>Initalize all the driver.  <pre><code>  // Initialize Serial communication\n  Serial.begin(115200);\n  IRSensors::Init();\n  MotorControl::DCMotorControl::Init();\n  MotorControl::ServoMotorControl::Init();\n  Encoder::Init();\n  Serial.println(\"Motors Pin Initialized.\");\n  UltrasonicSensor::Init();\n  Buzzer::Init();\n</code></pre></p> <p>Then create the tasks and pin them to the core. </p> <pre><code>  xTaskCreatePinnedToCore(\n    LEDBlinkingTask, \"Blinking\", 2000, NULL, 1, &amp;LEDBlinkingTaskHandle, 1);\n\n  xTaskCreatePinnedToCore(\n    MovementTask, \"Movement\", 12000, NULL, 2, &amp;MovementTaskHandle, 1);\n\n  xTaskCreatePinnedToCore(\n    SpeedControlTask, \"SpeedControl\", 10000, NULL, 2, &amp;SpeedControlTaskTCB, 1);\n\n  Serial.println(\"Robot initialized and running\");\n  vTaskDelay(10);\n</code></pre>"},{"location":"skeleton_code/main/#void-loop","title":"<code>void loop()</code>","text":"<p>THERE SHOULD BE NOTHING INSIDE <code>loop()</code>!!!</p> <p>MCU WILL NOT RUN ANY CODE INSIDE <code>loop()</code>!!!</p>"},{"location":"skeleton_code/motor/","title":"Motor Control","text":""},{"location":"skeleton_code/motor/#detail-code-for-motorcontrolhpp-motorcontrolcpp","title":"Detail code for <code>MotorControl.hpp</code> &amp; <code>MotorControl.cpp</code>","text":"<p>This section includes the control of the DC motor (Left &amp; right wheel) with the encoder setup to compute the RPM of the DC motor, servo motor (Front wheel).</p>"},{"location":"skeleton_code/motor/#dc-motor","title":"DC Motor","text":""},{"location":"skeleton_code/motor/#setting-up-the-pwm-channels-for-dc-motor","title":"Setting up the PWM Channel(s) for DC motor","text":"<p>For PWM channel, Setting as below.  PWM: Frequency, Resolution, Dutycycle Motor: ID, IN1 Channel, IN2 Channel, Speed </p> <pre><code>namespace MotorControl {\n  // Configuration of DC Motor (Side Wheels)\n  struct DCMotor\n  {\n    // PWM Configuration\n    const uint16_t PWMFrequency = 2000;\n    const uint8_t PWMResolution = 12;\n    uint16_t PWMDuty = 0;\n    uint8_t MotorID = 0; // ID = 1 (Left), = 2 (Right)\n    uint8_t PWMChannelIN1 =\n      0; // ensure the PWM channel for different motor is not the same\n    uint8_t PWMChannelIN2 = 0;\n    // Adjustable Parameter\n    uint16_t Speed = 0; // Init set to 0\n  }}\n</code></pre>"},{"location":"skeleton_code/motor/#the-use-of-extern","title":"The use of <code>extern</code>","text":"<p>To give them external linkage and make them accessible across multiple translation units, extern must be explicitly used in their declarations in all files, including the one where they are defined. </p>"},{"location":"skeleton_code/motor/#in-motorcontrolhpp","title":"In <code>MotorControl.hpp</code>,","text":"<pre><code>  extern DCMotor LeftWheel;\n  extern DCMotor RightWheel;\n</code></pre>"},{"location":"skeleton_code/motor/#in-motorcontrolcpp","title":"In <code>MotorControl.cpp</code>,","text":""},{"location":"skeleton_code/motor/#global-motor-instances","title":"Global motor instances","text":"<pre><code>namespace MotorControl {\n  DCMotor LeftWheel;\n  DCMotor RightWheel;\n\n}\n</code></pre>"},{"location":"skeleton_code/motor/#functions-for-controlling-dc-motors","title":"Functions for controlling DC motors","text":"<pre><code>  namespace DCMotorControl {\n  /*Initialization of PWM channels for DC Motors*/\n    void Init();\n    void TurnClockwise(DCMotor&amp; Motor);\n    void TurnAntiClockwise(DCMotor&amp; Motor);\n    void Stop(DCMotor&amp; Motor);\n  };\n</code></pre>"},{"location":"skeleton_code/motor/#void-dcmotorcontrolinit","title":"<code>void DCMotorControl::Init()</code>","text":"<pre><code>void MotorControl::DCMotorControl::Init()\n{\n  // Setup the Motor ID to the struct\n  LeftWheel.MotorID = 1;\n  LeftWheel.PWMChannelIN1 = 1;\n  LeftWheel.PWMChannelIN2 = 2;\n\n  RightWheel.MotorID = 2;\n  RightWheel.PWMChannelIN1 = 3;\n  RightWheel.PWMChannelIN2 = 4;\n\n  // Setup PWM channels for DC Motors (Side Wheels)\n  ledcAttachChannel(Pinout::LeftMotorIn1,\n                    LeftWheel.PWMFrequency,\n                    LeftWheel.PWMResolution,\n                    LeftWheel.PWMChannelIN1);\n  ledcAttachChannel(Pinout::LeftMotorIn2,\n                    LeftWheel.PWMFrequency,\n                    LeftWheel.PWMResolution,\n                    LeftWheel.PWMChannelIN2);\n  ledcAttachChannel(Pinout::RightMotorIn1,\n                    RightWheel.PWMFrequency,\n                    RightWheel.PWMResolution,\n                    RightWheel.PWMChannelIN1);\n  ledcAttachChannel(Pinout::RightMotorIn2,\n                    RightWheel.PWMFrequency,\n                    RightWheel.PWMResolution,\n                    RightWheel.PWMChannelIN2);\n\n  // Set all the PWM Channels' Dutycycle to 0\n  ledcWriteChannel(LeftWheel.PWMChannelIN1, 0);\n  ledcWriteChannel(LeftWheel.PWMChannelIN2, 0);\n  ledcWriteChannel(RightWheel.PWMChannelIN1, 0);\n  ledcWriteChannel(RightWheel.PWMChannelIN2, 0);\n};\n</code></pre>"},{"location":"skeleton_code/motor/#spinning-the-dc-motor","title":"Spinning the DC motor","text":"<p>Refer to the datasheet of the motor sheet (Motor driver)</p> <p>Check out URL: DRV8871 3.6-A Brushed DC Motor Driver With Internal Current Sense (PWM Control) for the latest docs.</p> <p></p>"},{"location":"skeleton_code/motor/#void-motorcontroldcmotorcontrolturnclockwisemotorcontroldcmotor-motor","title":"<code>void MotorControl::DCMotorControl::TurnClockwise(MotorControl::DCMotor&amp; Motor)</code>","text":"<p>@brief Spin the motor clockwise, package the function in struct dependent.</p> <p>@param Motor (MotorControl::DCMotor&amp; Motor) (i.e. LeftWheel / RightWheel)</p> <pre><code>void MotorControl::DCMotorControl::TurnClockwise(MotorControl::DCMotor&amp; Motor)\n{\n  ledcWriteChannel(Motor.PWMChannelIN1, Motor.Speed);\n  ledcWriteChannel(Motor.PWMChannelIN2, 0);\n};\n</code></pre>"},{"location":"skeleton_code/motor/#void-motorcontroldcmotorcontrolturnanticlockwisemotorcontroldcmotor-motor","title":"<code>void MotorControl::DCMotorControl::TurnAntiClockwise(MotorControl::DCMotor&amp; Motor)</code>","text":"<p>@brief Spin the motor anti-clockwise, package the function in struct dependent.</p> <p>@param Motor (MotorControl::DCMotor&amp; Motor) (i.e. LeftWheel / RightWheel)</p> <pre><code>void MotorControl::DCMotorControl::TurnAntiClockwise(MotorControl::DCMotor&amp; Motor)\n{\n\n  ledcWriteChannel(Motor.PWMChannelIN1, 0);\n  ledcWriteChannel(Motor.PWMChannelIN2, Motor.Speed);\n};\n</code></pre>"},{"location":"skeleton_code/motor/#void-motorcontroldcmotorcontrolstopmotorcontroldcmotor-motor","title":"<code>void MotorControl::DCMotorControl::Stop(MotorControl::DCMotor&amp; Motor)</code>","text":"<p>@brief Stop the motor, package the function in struct dependent.</p> <p>@param Motor (MotorControl::DCMotor&amp; Motor) (i.e. LeftWheel / RightWheel)</p> <p>Refer to the datasheet, to stop the DC motor, both of IN1 and IN2 should be pull-high (100% dutycycle, i.e. 4096 for 12-bit PWM resolution)</p> <pre><code>void MotorControl::DCMotorControl::Stop(MotorControl::DCMotor&amp; Motor)\n{\n  ledcWriteChannel(Motor.PWMChannelIN1, 4096);\n  ledcWriteChannel(Motor.PWMChannelIN2, 4096);\n};\n</code></pre>"},{"location":"skeleton_code/motor/#encoder-for-dc-motor","title":"Encoder for DC Motor","text":""},{"location":"skeleton_code/motor/#setting-up-the-encoder-for-dc-motor-n20","title":"Setting up the encoder for DC motor (n20)","text":"<ul> <li>The gearbox used on the car is highlight in red, and the rpm of the motor (without any payload) is 300.</li> </ul>"},{"location":"skeleton_code/motor/#creating-struct-for-encoder","title":"Creating struct for encoder","text":"<p>To find the rpm of the motor, encoder with A and B is used to detect the rotation of the magnet attaches to the motor. </p> <p>In <code>MotorControl.hpp</code>,  <pre><code>// Create a struct to handle 2 motors encoder\nstruct Encoder_t\n{\n  int pinAState;\n  int pinBState;\n  int Encoder_A;\n  int Encoder_B;\n};\n</code></pre></p>"},{"location":"skeleton_code/motor/#constant-for-encoder","title":"Constant for encoder","text":"<ul> <li>encoderResolution is tested by full speed (100% dutycycle) and count the pulses. Since the rpm of the motor without payload is 300, the pulse per rotation of the motor can be found. </li> </ul> <pre><code>/*Constants for Encoder\n  Find out the encoder resolution by yourself */\nconst int encoderResolution = 320; // Number of pulses per revolution\nconst unsigned long interval = 50; // Time interval in milliseconds 50ms\n</code></pre> <pre><code>// Global motor encoder\nextern Encoder_t EncoderLeft;\nextern Encoder_t EncoderRight;\n</code></pre> <p>In <code>MotorControl.cpp</code> <pre><code>namespace MotorControl {\n  ServoMotor FrontWheel;\n}\n</code></pre></p>"},{"location":"skeleton_code/motor/#rpm-counter","title":"RPM Counter","text":""},{"location":"skeleton_code/motor/#setup-of-the-rpm-counter-struct","title":"Setup of the RPM counter struct","text":"<p>In <code>MotorControl.hpp</code>,  <pre><code>/*Encoder to RPM Function and Settings\n  Creating RPMCounter_t for 2 Wheel Setting\n  */\nstruct RPMCounter_t\n{\n  volatile int encoderPulses;\n  unsigned long previousMillis;\n  volatile float rpm;\n};\n\nextern RPMCounter_t LeftWheelRPM;\nextern RPMCounter_t RightWheelRPM;\n</code></pre></p>"},{"location":"skeleton_code/motor/#functions-for-encoder","title":"Functions for encoder","text":"<ul> <li>Interrupts are used for the triggering of the encoder pin </li> </ul> <pre><code>namespace Encoder {\n  /*Interrupt for the encoder for both left &amp; right wheel*/\n  void handleLeftEncoderInterrupt();\n  void handleRightEncoderInterrupt();\n  void Init();\n  void RPMCounterFromEncoder(RPMCounter_t&amp; Counter);\n};\n</code></pre>"},{"location":"skeleton_code/motor/#initalization-of-rpm-counter","title":"Initalization of RPM counter","text":"<p>In <code>MotorControl.cpp</code>, </p> <pre><code>/*Init the Enocoder related Variables before the task starts*/\nEncoder_t EncoderLeft = { 0,\n                          0,\n                          Pinout::LeftMotorEncoderA,\n                          Pinout::LeftMotorEncoderB };\nEncoder_t EncoderRight = { 0,\n                           0,\n                           Pinout::RightMotorEncoderA,\n                           Pinout::RightMotorEncoderB };\n\n/*Define 2 Sets of Variables using RPMCounter_t for 2 Wheel\nInit the RPM related Variables before the task starts   */\nRPMCounter_t LeftWheelRPM = { 0, 0, 0 };\nRPMCounter_t RightWheelRPM = { 0, 0, 0 };\n</code></pre>"},{"location":"skeleton_code/motor/#impentation-of-interrupt-in-esp32","title":"Impentation of interrupt in ESP32","text":"<p>For the detail API of  <code>IRAM_ATTR</code>, please refer to the offical documentation in esp32 website. </p> <p>URL: ESP32 Memory Types</p> <p>In <code>MotorControl.cpp</code>, <code>Encoder</code> namespace, </p>"},{"location":"skeleton_code/motor/#void-iram_attr-encoderhandleleftencoderinterrupt","title":"<code>void IRAM_ATTR Encoder::handleLeftEncoderInterrupt()</code>","text":"<pre><code>/*Interrupt Service Routine Function\n  Since attachInterrupt() cannot using non Static function\n  Below are 2 IRAM_ATTR function for handle the interrupts for the encoder*/\nnamespace Encoder {\n  void IRAM_ATTR handleLeftEncoderInterrupt()\n  {\n    // init the local variable\n    int change = 0;\n\n    // Read the current state of the encoder pins\n    EncoderLeft.pinAState = digitalRead(EncoderLeft.Encoder_A);\n    EncoderLeft.pinBState = digitalRead(EncoderLeft.Encoder_B);\n\n    // Determine the direction of rotation based on the phase change\n    if (EncoderLeft.pinAState != EncoderLeft.pinBState) {\n      change = (EncoderLeft.pinAState == HIGH) ? 1 : 0;\n    } else {\n      change = (EncoderLeft.pinAState == HIGH) ? 0 : 1;\n    }\n\n    // Update the encoder count\n    LeftWheelRPM.encoderPulses += change;\n  };\n</code></pre>"},{"location":"skeleton_code/motor/#void-iram_attr-encoderhandlerightencoderinterrupt","title":"<code>void IRAM_ATTR Encoder::handleRightEncoderInterrupt()</code>","text":"<pre><code>void IRAM_ATTR handleRightEncoderInterrupt()\n{\n  // init the local variable\n  int change = 0;\n\n  // Read the current state of the encoder pins\n  EncoderRight.pinAState = digitalRead(EncoderRight.Encoder_A);\n  EncoderRight.pinBState = digitalRead(EncoderRight.Encoder_B);\n\n  // Determine the direction of rotation based on the phase change\n  if (EncoderRight.pinAState != EncoderRight.pinBState) {\n    change = (EncoderRight.pinAState == HIGH) ? 1 : 0;\n  } else {\n    change = (EncoderRight.pinAState == HIGH) ? 0 : 1;\n  }\n\n  // Update the encoder count\n  RightWheelRPM.encoderPulses += change;\n};\n</code></pre>"},{"location":"skeleton_code/motor/#encoderinit","title":"<code>Encoder::Init()</code>","text":"<ul> <li>Initialization of ALL the GPIO pins for encoder. </li> <li>Attach the interrupts to MCU, which to tell MCU to enable the interrupts.</li> </ul> <pre><code>  void Init()\n  {\n    // Init the PinMode for the Encoder Pins\n    pinMode(Pinout::LeftMotorEncoderA, INPUT_PULLUP);\n    pinMode(Pinout::LeftMotorEncoderB, INPUT_PULLUP);\n\n    pinMode(Pinout::RightMotorEncoderA, INPUT_PULLUP);\n    pinMode(Pinout::RightMotorEncoderB, INPUT_PULLUP);\n\n    // Attach the interrupt service routine to the encoder pins\n    attachInterrupt(digitalPinToInterrupt(Pinout::LeftMotorEncoderA),\n                    handleLeftEncoderInterrupt,\n                    CHANGE);\n    attachInterrupt(digitalPinToInterrupt(Pinout::RightMotorEncoderA),\n                    handleRightEncoderInterrupt,\n                    CHANGE);\n    Serial.println(\"Interrupt Pins Initialized\");\n  };\n</code></pre>"},{"location":"skeleton_code/motor/#void-encoderrpmcounterfromencoderrpmcounter_t-counter","title":"<code>void Encoder::RPMCounterFromEncoder(RPMCounter_t&amp; Counter)</code>","text":"<p>@brief Take the encoder reading in a period of time and convert the data to RPM and store the data in the <code>RPMCounter_t</code> structure.</p> <p>@para <code>RPMCounter_t&amp;</code> -- RPM Counter struct (i.e. <code>LeftWheelRPM</code>/<code>RightWheelRPM</code>) <pre><code>  void RPMCounterFromEncoder(RPMCounter_t&amp; Counter)\n  {\n    unsigned long currentMillis = millis();\n\n    // Check if the time interval has elapsed\n    if (currentMillis - Counter.previousMillis &gt;= interval) {\n      // Calculate RPM\n      float rotations = float(Counter.encoderPulses) / ((float)encoderResolution);\n      float time =\n        (currentMillis - Counter.previousMillis) / 1000.0f; // Convert to seconds\n      Counter.rpm = (rotations / time) * 60.0f;\n\n      // Reset encoder pulse count and update previousMillis\n      Counter.encoderPulses = 0;\n      Counter.previousMillis = currentMillis;\n\n      // Print RPM\n      Serial.println(Counter.rpm);\n    }\n  }\n}\n</code></pre></p>"},{"location":"skeleton_code/motor/#servo-motor","title":"Servo Motor","text":""},{"location":"skeleton_code/motor/#setting-up-servo-motor-pwm-channel","title":"Setting up Servo Motor PWM Channel","text":"<p>For Servo Motor, Frequency MUST be 50Hz Servo Motor: Target angle <pre><code>  // Configuration of Servo Motor (Front Wheel)\n  struct ServoMotor\n  {\n    const uint8_t PWMFrequency = 50; // PWM must be in 50Hz\n    const uint8_t PWMResolution = 12;\n    uint16_t PWMDuty = 0;\n    const uint8_t PWMChannel = 8; // Ideally select between 5-10\n    float TargetAngle = 0.0f;\n  };\n\n  ServoMotor FrontWheel;\n</code></pre></p>"},{"location":"skeleton_code/motor/#functions-for-servo-motor-front-wheel","title":"Functions for servo motor (Front wheel)","text":"<pre><code>  namespace ServoMotorControl {\n    /*Initialization of PWM Channel for Servo Motor*/\n    void Init();\n    void TurnDeg(ServoMotor&amp; Motor); // in deg\n  }\n  // Global motor instances\n\n\n  extern ServoMotor FrontWheel;\n</code></pre>"},{"location":"skeleton_code/motor/#void-motorcontrolservomotorcontrolinit","title":"<code>void MotorControl::ServoMotorControl:Init()</code>","text":"<p>@brief Initalization of the PWM channel for servo motor.</p> <pre><code>void MotorControl::ServoMotorControl::Init()\n{\n  // Setup PWM channel for Servo Motor (Front Wheel)\n  ledcAttachChannel(Pinout::ServoPin,\n                    FrontWheel.PWMFrequency,\n                    FrontWheel.PWMResolution,\n                    FrontWheel.PWMChannel);\n  // Set all the PWM Channels' Dutycycle to 0\n  ledcWriteChannel(FrontWheel.PWMChannel, 0);\n};\n</code></pre>"},{"location":"skeleton_code/motor/#void-motorcontrolservomotorcontrolturndegmotorcontrolservomotor-motor","title":"<code>void MotorControl::ServoMotorControl::TurnDeg(MotorControl::ServoMotor&amp; Motor)</code>","text":"<p>@brief Control the PWM dutycycle to adjust the angle of the servo motor (Frontwheel)</p> <p>@para <code>MotorControl::ServoMotor&amp; Motor</code> The struct of the servo motor (i.e. FrontWheel)</p> <pre><code>/*For SG90 Servo Motor\nPWM         --&gt; 50Hz  (20ms)\nDutycycle   --&gt; 1-2ms (5-10%)*/\nvoid MotorControl::ServoMotorControl::TurnDeg(MotorControl::ServoMotor&amp; Motor)\n{\n  Motor.PWMDuty = (float(Motor.TargetAngle) / 90.0f) * 51.2f + 25.0f;\n  ledcWriteChannel(Motor.PWMChannel, Motor.PWMDuty);\n  /*For Debug*/\n  // Serial.print(\"Servo Degree: \");\n  // Serial.println(Degree);\n  // Serial.print(\"Dutycycle: \");\n  // Serial.println(Dutycycle);\n};\n</code></pre>"},{"location":"skeleton_code/movement/","title":"Movement","text":""},{"location":"skeleton_code/movement/#detail-code-for-movementhpp-and-movementcpp","title":"Detail code for <code>Movement.hpp</code> and <code>Movement.cpp</code>","text":""},{"location":"skeleton_code/movement/#declartions-of-configuration-of-angle-of-the-car","title":"Declartions of configuration of angle of the car","text":"<pre><code>namespace Movement {\n    // Servo positions\n    /*Servo Physical Config on Car in deg\n          45  90  135   \n            \\  |  /              \n             \\ | /\n              \\|/ \n       0 ------------- 180        */\n    const uint8_t servoLeft   = 45;\n    const uint8_t servoCenter = 90;\n    const uint8_t servoRight  = 135;\n}\n</code></pre>"},{"location":"skeleton_code/movement/#functions-of-controlling-the-car-movements","title":"Functions of controlling the car movements","text":"<p>Creating the motion by utilizing front, left, right wheel rotations. </p> <p>The following function is based on differental drive when <code>L = -R</code> (see the fig.)</p> <p></p> <p>In <code>Movement.hpp</code>, <pre><code>namespace Movement {\n    void RotateLeft();\n    void RotateRight();\n    void MoveForward();\n    void MoveBackward();\n    void Stop();\n}\n</code></pre></p>"},{"location":"skeleton_code/movement/#void-movementrotateright","title":"<code>void Movement::RotateRight()</code>","text":"<p>@brief Make the car turns right.  <pre><code>    void Movement::RotateRight(){\n        /*The following config is for differential driving, i.e. Front Wheel always 90 deg facing forward */\n        /*Config. of DC Motor (Side Wheel)*/\n        MotorControl::DCMotorControl::TurnAntiClockwise(MotorControl::LeftWheel);\n        MotorControl::DCMotorControl::TurnClockwise(MotorControl::RightWheel);\n\n        /*Setting the servo motor to 90 deg */\n        MotorControl::FrontWheel.TargetAngle = servoCenter;\n        MotorControl::ServoMotorControl::TurnDeg(MotorControl::FrontWheel);\n    };\n</code></pre></p>"},{"location":"skeleton_code/movement/#void-movementrotateleft","title":"<code>void Movement::Rotateleft()</code>","text":"<p>@brief Make the car turns left.  <pre><code>    void Movement::RotateLeft(){\n        /*The following config is for differential driving, i.e. Front Wheel always 90 deg facing forward */\n        /*Config. of DC Motor (Side Wheel)*/\n        MotorControl::DCMotorControl::TurnClockwise(MotorControl::LeftWheel);\n        MotorControl::DCMotorControl::TurnAntiClockwise(MotorControl::RightWheel);\n\n        /*Setting the servo motor to 90 deg */\n        MotorControl::FrontWheel.TargetAngle = servoCenter;\n        MotorControl::ServoMotorControl::TurnDeg(MotorControl::FrontWheel);\n    };\n</code></pre></p>"},{"location":"skeleton_code/movement/#void-movementmoveforward","title":"<code>void Movement::MoveForward()</code>","text":"<p>@brief Make the car moves forwards. <pre><code>    void Movement::MoveForward(){\n        /*The following config is for differential driving, i.e. Front Wheel always 90 deg facing forward */\n        /*Config. of DC Motor (Side Wheel)*/\n        MotorControl::DCMotorControl::TurnAntiClockwise(MotorControl::LeftWheel);\n        MotorControl::DCMotorControl::TurnAntiClockwise(MotorControl::RightWheel);\n\n\n        /*Setting the servo motor to 90 deg */\n        MotorControl::FrontWheel.TargetAngle = servoCenter;\n        MotorControl::ServoMotorControl::TurnDeg(MotorControl::FrontWheel);\n    };\n</code></pre></p>"},{"location":"skeleton_code/movement/#void-movementmovebackward","title":"<code>void Movement::MoveBackward()</code>","text":"<p>@brief Make the car moves backwards.  <pre><code>    void Movement::MoveBackward(){\n        /*The following config is for differential driving, i.e. Front Wheel always 90 deg facing forward */\n        /*Config. of DC Motor (Side Wheel)*/\n        MotorControl::DCMotorControl::TurnClockwise(MotorControl::LeftWheel);\n        MotorControl::DCMotorControl::TurnClockwise(MotorControl::RightWheel);\n\n        /*Setting the servo motor to 90 deg */\n        MotorControl::FrontWheel.TargetAngle = servoCenter;\n        MotorControl::ServoMotorControl::TurnDeg(MotorControl::FrontWheel);\n    };\n</code></pre></p>"},{"location":"skeleton_code/movement/#void-movementstop","title":"<code>void Movement::Stop()</code>","text":"<p>@brief Make the car stops. <pre><code>    void Movement::Stop(){\n        MotorControl::DCMotorControl::Stop(MotorControl::LeftWheel);\n        MotorControl::DCMotorControl::Stop(MotorControl::RightWheel);\n    }\n</code></pre></p>"},{"location":"skeleton_code/movement/#adjust-the-speed-of-motion","title":"Adjust the speed of motion","text":"<p>Refer to the <code>motor.md</code>, the functions in <code>MotorControl.hpp</code> are used.</p> <p>Since the struct of the motor (LeftWheel &amp; RightWheel) are created. There is a member in the <code>DCMotor</code> called <code>speed</code>. </p> <p>By adjusting the <code>speed</code> of <code>LeftWheel</code> &amp; <code>RightWheel</code>, the speed of the movement can be changed. </p>"},{"location":"skeleton_code/movement/#with-pid-control","title":"With PID control","text":"<p>In the <code>.ino</code>, (With PID driver)</p> <p>For the detail of the PID control, please refer to the <code>PID Section</code>. </p> <p>The following code is an example of the car moves forwards.</p> <p>@para <code>LeftWheelPID.target_val</code> Target speed of the leftwheel </p> <p>@para <code>RightWheelPID.target_val</code> Target speed of the rightwheel</p> <p>For an instance, both speed of the wheel fixed to <code>150.0f</code>.  <pre><code>        LeftWheelPID.target_val = 150.0f;\n        RightWheelPID.target_val = 150.0f;\n        Movement::MoveForward();\n        vTaskDelay(100/portTICK_PERIOD_MS); //delay for a duration of 100ms \n        //or use delay(100);\n</code></pre></p> <p>If a faster speed is needed, increase the value of <code>LeftWheelPID.target_val</code> &amp; <code>RightWheelPID.target_val</code>.  <pre><code>        LeftWheelPID.target_val = 300.0f;\n        RightWheelPID.target_val = 300.0f;\n        Movement::MoveForward();\n        vTaskDelay(100/portTICK_PERIOD_MS); //delay for a duration of 100ms \n        //or use delay(100);\n</code></pre></p>"},{"location":"skeleton_code/sensor/","title":"Sensors","text":""},{"location":"skeleton_code/sensor/#infrared-sensor-ir-sensor","title":"Infrared Sensor (IR Sensor)","text":""},{"location":"skeleton_code/sensor/#ir-configuration","title":"IR Configuration","text":"<pre><code> // IR Sensor Configuration\n    /*\n           L   M   R  \n            \\  |  /              \n             \\ | /       ^\n              \\|/        |\n              Car      Front\n\n    */\n</code></pre>"},{"location":"skeleton_code/sensor/#irsensorhpp","title":"<code>IRSensor.hpp</code>","text":"<p>Define the namespace <code>IRSensors</code> to encapsulate all IR sensor related functions and variables, thus to use functions and variables in the main code file <code>.ino</code>, need to add prefix with <code>IRSensors::</code>.</p> <pre><code>namespace IRSensors {\n    // ...\n}\n</code></pre> <p>Define the <code>RobotState</code> enum (list of <code>uint8_t</code> numbers) to represent the various states of the robot based on the readings from the three IR sensors (Left, Middle, Right).</p> <pre><code>// Robot States\n    enum RobotState : uint8_t {\n        /* The logic of the IR sensor and its output\n        |    Tile Colour   |  digitalRead() |\n        |      Black       |    1 (HIGH)    |\n        |      White       |     0 (LOW)    |\n         */\n        /*  Logic Reference Table\n        |    uint8_t     |     boolean ( digitalRead() )  |\n        |   RobotState    |   IR_L   |   IR_M   |   IR_R   |\n        |        0        |     0    |     1    |     0    |\n        |        1        |     1    |     1    |     0    |\n        |        2        |     1    |     1    |     1    |\n        |        3        |     1    |     0    |     1    |\n        |        4        |     0    |     1    |     1    |\n        |        5        |     0    |     0    |     1    |\n        |        6        |     1    |     0    |     0    |\n        |        7        |     0    |     0    |     0    |\n\n        |*/\n        Middle_ON_Track,        // 0 \n        Left_Middle_ON_Track,   // 1\n        ALL_ON_Track,           // 2\n        Left_Right_ON_Track,    // 3\n        Middle_Right_ON_Track,   // 4\n        Right_ON_Track,         // 5\n        Left_ON_Track,          // 6\n        All_OFF_Track           // 7 \n    };\n</code></pre> <p>Define the <code>IRSensorData</code> structure to hold the readings from the three IR sensors and the current state of the robot.</p> <pre><code> // IR Sensor Structure\nstruct IRSensorData {\n    // Sensor states\n    bool Read_IR_L;\n    bool Read_IR_M;\n    bool Read_IR_R;\n    uint8_t state;\n};\n</code></pre> <p>Declare a global instance of <code>IRSensorData</code> that can be accessed across different files.</p> <pre><code>// Global IR sensor instance\nextern IRSensorData IRData;\n</code></pre> <p>Declare the initialization and sensor reading functions for the IR sensors. The actual implementations will be in the <code>IRSensors.cpp</code> file.</p> <pre><code>// Function declarations\nvoid Init();\nuint8_t ReadSensorState(IRSensorData&amp; IRData);\n</code></pre>"},{"location":"skeleton_code/sensor/#irsensorscpp","title":"<code>IRSensors.cpp</code>","text":"<p>Initialize the global IR sensor instance with default values of <code>false</code> for each sensor reading and <code>Middle_ON_Track</code> for the robot state. <pre><code>// Global IR sensor instance\nIRSensorData IRData = {\n    false,          //bool Read_IR_L;\n    false,          //bool Read_IR_M;\n    false,          //bool Read_IR_R;\n    Middle_ON_Track //RobotState state;\n    };\n</code></pre></p> <p>Configure the GPIO setup for the IR Sensor pins <pre><code>void Init() {\n    // Initialize IR sensor pins\n    pinMode(Pinout::IRLeft, INPUT);\n    pinMode(Pinout::IRMiddle, INPUT);\n    pinMode(Pinout::IRRight, INPUT);\n};\n</code></pre></p> <p>Function to read the current state of the IR sensors and match to the robot's state based on the sensor readings. <pre><code>uint8_t ReadSensorState(IRSensorData&amp; IRData){\n    /*Scan all the IR sensors to get the current status of the car*/\n    IRData.Read_IR_L = digitalRead(Pinout::IRLeft);\n    IRData.Read_IR_M = digitalRead(Pinout::IRMiddle);\n    IRData.Read_IR_R = digitalRead(Pinout::IRRight);\n\n    /*According to the current status of the IR Sensors, determine the RobotState*/\n    if(IRData.Read_IR_L == 0 &amp;&amp; IRData.Read_IR_M == 1 &amp;&amp; IRData.Read_IR_R == 0 ){\n        return Middle_ON_Track;\n    } else if (...){\n        // ...\n    }\n    // Continue for other states...\n\n    return 10; //Error Code if none of condition fits.\n}\n</code></pre></p>"},{"location":"skeleton_code/sensor/#rfid-reader","title":"RFID Reader","text":"<p>The code of the RFID Reader (MFRC522) is based on an open-source repo in github.</p> <p>Repo URL: miguelbalboa/rfid</p> <p>The datasheet of the MFRC522 can be found here: (MFRC522 Datasheet)</p> <p>The driver in skeleton code is modified for running I2C protocol, which the repo above is for SPI protocol. </p> <p>The driver consist of the following files: * <code>MFRC522_I2C.hpp</code> * <code>MFRC522_I2C.cpp</code></p> <p>This manual will ONLY guide you how to call the API in your <code>.ino</code> file. </p>"},{"location":"skeleton_code/sensor/#inertial-measurement-unit-imu","title":"Inertial Measurement Unit (IMU)","text":"<p>The code of the IMU (ICM42688-P) is based on an open-source repo in github. </p> <p>Repo URL: finani/ICM42688 </p> <p>For detail please refer to the github page. </p> <p>The datasheet of the ICM42688-P can be found here: ICM42688-P Datasheet  The driver consist of the following files:  * <code>IMU.h</code> * <code>IMU.cpp</code> * <code>register.h</code></p> <p>This manual will ONLY guide you how to call the API in your <code>.ino</code> file. </p>"},{"location":"skeleton_code/sensor/#ultrasonic-sensor","title":"Ultrasonic Sensor","text":"<p>In <code>UltrasonicSensor.hpp</code>,  <pre><code>namespace UltrasonicSensor{\n  void Init();\n  float GetDistance();\n}\n</code></pre></p> <p>In <code>UltrasonicSensor.cpp</code>  Setting the constant value of speed of sound:  <pre><code>#define SOUND_SPEED 340\n</code></pre></p>"},{"location":"skeleton_code/sensor/#void-ultrasonicsensorinit","title":"<code>void UltrasonicSensor::Init()</code>","text":"<p>Initialization of the ultrasonic sensor pin, echo and trig pin.  <pre><code>void UltrasonicSensor::Init(){ \n  pinMode(Pinout::UltrasonicTrigPin, OUTPUT); // Sets the trigPin as an Output\n  pinMode(Pinout::UltrasonicEchoPin, INPUT); // Sets the echoPin as an Input\n  Serial.println(\"Ultrasonic Sensor is set\");\n}\n</code></pre></p>"},{"location":"skeleton_code/sensor/#float-ultrasonicsensorgetdistane","title":"<code>float UltrasonicSensor::GetDistane()</code>","text":"<p>@brief Ouput the distance of the ultrasonic sensor measured. (in meter)</p> <p>@return Distance (in float)</p> <pre><code>float UltrasonicSensor::GetDistance(){\n  long duration = 0;  //initalize the temp para. \n  float distance = 0; \n  // Clears the trigPin\n  digitalWrite(Pinout::UltrasonicTrigPin, LOW);\n  delayMicroseconds(2);\n  // Sets the trigPin on HIGH state for 10 micro seconds\n  digitalWrite(Pinout::UltrasonicTrigPin, HIGH);\n  delayMicroseconds(10);\n  digitalWrite(Pinout::UltrasonicTrigPin, LOW);\n\n  // Reads the echoPin, returns the sound wave travel time in microseconds\n  duration = pulseIn(Pinout::UltrasonicEchoPin, HIGH);\n\n  // Calculate the distance (in m)\n  distance = (duration * SOUND_SPEED/100)/2;\n  return distance; \n  //For Debug Use\n  // Prints the distance in the Serial Monitor\n  // Serial.print(\"Distance (cm): \");\n  // Serial.println(distance/100);\n}\n</code></pre>"},{"location":"skeleton_code/sensor/#buzzer","title":"Buzzer","text":"<p>The buzzer used on the board is Passive Buzzer which the buzzer is controlled by the PWM signal from the MCU. </p> <p>The driver consist of the following files:  * <code>Buzzer.hpp</code> * <code>Buzzer.cpp</code> * <code>pitches.h</code></p> <p>In <code>Buzzer.hpp</code>, A mdelody with the respective duration of each note is created for demo purpose.  <pre><code>extern int DemoMelody[];\nextern int DemoDurations[];\n</code></pre></p> <p>In <code>Buzzer.cpp</code>,  <pre><code>//Here is a reference for the melody and duration format, also refer to the pitches.h\nint DemoMelody[] = {\n  // Phrase 1: Intro Fanfare (16th notes)\n  NOTE_FS4, NOTE_G4, NOTE_A4, NOTE_B4, NOTE_C5, NOTE_D5, NOTE_E5, NOTE_FS5,\n  // Phrase 2: Countdown Motif\n  NOTE_B4, NOTE_C5, NOTE_B4, NOTE_A4, NOTE_FS4, NOTE_A4, NOTE_B4,\n\n  NOTE_B4, NOTE_B4, NOTE_B4, NOTE_B6\n};\n\n// Note Durations: \n// 2 = half, 4 = quarter, 8 = eighth, 16 = sixteenth\nint DemoDurations[] = { \n  // Durations for Intro Fanfare (all 16th notes)\n  16, 16, 16, 16, 16, 16, 16, 16,\n  // Durations for Countdown Motif\n  8, 8, 8, 8, 4, 8, 2,\n\n  2, 2, 2, 1\n};\n</code></pre></p>"},{"location":"skeleton_code/sensor/#fucntion-for-buzzer","title":"Fucntion for Buzzer","text":"<p>In the <code>Buzzer</code> namespace,  <pre><code>namespace Buzzer {\nvoid Init();\nvoid PlayMelody(int* melody, int* durations);\n}\n</code></pre></p>"},{"location":"skeleton_code/sensor/#void-buzzerinit","title":"<code>void Buzzer::Init()</code>","text":"<p>Initialization of the Buzzer pin to <code>OUTPUT</code> <pre><code>void Buzzer::Init(){\n  pinMode(Pinout::Buzzer, OUTPUT);\n}\n</code></pre></p>"},{"location":"skeleton_code/sensor/#void-playmelodyint-melody-int-durations","title":"<code>void PlayMelody(int* melody, int* durations)</code>","text":"<p>@brief Play the melody with the respective duration of each note once</p> <p>@para <code>int* melody</code> Pointer of the melody (e.g. DemoMelody)</p> <p>@para <code>int* durations</code> Pointer of the duration (e.g. DemoDurations)</p> <ul> <li>Noted that the length of the <code>int melody</code> and <code>int durations</code> MUST BE THE SAME, otherwise the function will not work properly, </li> </ul> <pre><code>void Buzzer::PlayMelody(int *melody, int *durations){\n      // Calculate the number of notes in the melody\n    int numNotes = sizeof(melody) / sizeof(melody[0]);\n\n    // Iterate over the notes\n    for (int thisNote = 0; thisNote &lt; numNotes; thisNote++) {\n\n      // To calculate the note duration, take one second divided by the note type.\n      // e.g., quarter note = 1000 / 4, eighth note = 1000/8, etc.\n      int noteDuration = 1000 / durations[thisNote];\n\n      // Play the note using the tone() function\n      tone(Pinout::Buzzer, melody[thisNote], noteDuration);\n\n      // To distinguish between notes, set a minimum time between them.\n      // The note's duration + 30% (to create a short pause) works well.\n      int pauseBetweenNotes = noteDuration * 1.30;\n      delay(pauseBetweenNotes);\n\n      // Stop the tone playing (creates a cleaner staccato effect)\n      noTone(Pinout::Buzzer);\n    }\n    // Final cleanup - ensure the PWM channel is detached\n    ledcDetach(Pinout::Buzzer);\n\n}\n</code></pre>"}]}